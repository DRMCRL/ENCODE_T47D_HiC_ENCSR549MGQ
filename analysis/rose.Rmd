---
title: "Dectection of Super-Enhancers Using ROSE"
author: "Stephen Pederson<br>Dame Roma Mitchell Cancer Research Laboratories<br>Adelaide Medical School<br>University of Adelaide"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 10,
  fig.height = 8
)
```


```{r packages}
library(rtracklayer)
library(tidyverse)
library(Gviz)
library(glue)
library(Rsamtools)
library(pander)
library(scales)
library(GenomicInteractions)
library(InteractionSet)
library(magrittr)
```

```{r setOpts}
theme_set(theme_bw())
panderOptions("big.mark", ",")
```


# Introduction

This is a manual re-implementation of the ROSE algorithm and relies on ChIP peaks from H3K21AC data being previously called.
These are assumed to be candidate regions for both promoters and enhancers.

## Required Data

Before running the ROSE algorithm, the following files must be sourced

1. Consensus Peaks for each treatment as `.bed` files
2. Merged `.bam` files for all replicates within each treatment group and the control sample
3. BigWig files for each replicate, purely for the purposes of visualisation

## Steps of the ROSE Algorithm

The steps are as follows:

1. Remove any regions which overlap a TSS and set aside as promoters
    + *Promoters were restricted to genes detected as expressed in the associated RNA-Seq dataset*
    + TSS regions are extended by 1.5kb upstream and 500bp downstream to give a broader 2kb TSS/promoter region, however the size of the peaks effectively defines the promoter
2. Join any remaining candidate enhancers within 12.5kb
    + Remove any candidate regions shorter than 1kb as these will not make the cut
3. Count reads aligned within each region to get the number of reads
    + Alignments were pre-filtered such that only reads with a `MAPQ` score > 10 were retained
    + Strandedness of aligned reads was not taken into account
4. Counts are transformed into Reads Per Million (`rpm`) by dividing by the total number of reads aligned within each bam file, divided by 10^-6^
5. `rpm` values within each region are divided by the region width to give `rpm/bp`
6. `rpm/bp` values are then background corrected by subtracting the values observed in the control sample
    + Any `rpm/bp` < 0 are automatically set to 0 when calculating the cutoff
7. Candidate enhancers are then ranked and the point found for which the slope of the tangent line drops below 1

Unlike other implementations of ROSE, standard Bioconductor data structures will be used.

Additionally, the functions `calculate_cutoff()` and `numPts_below_line()` were taken directly from the main [ROSE github software repository](https://github.com/rakarnik/ROSE/blob/master/ROSE_callSuper.R)

# Data Setup

## Gene and Transcript Models

```{r rnaseq}
rnaseq <- here::here("data/external/RNASeq/t47d_DHT_StrippedSerum_RNASeq_topTable.tsv") %>%
  read_tsv()
```


```{r getTSS}
transModels <- here::here("output/transModels.rds") %>%
  read_rds()
tss <- transModels %>%
  subset(gene %in% rnaseq$gene_id) %>%
  split(f = .$transcript) %>%
  as("GRangesList") %>%
  range() %>%
  unlist() %>%
  resize(width = 1, fix = "start") %>%
  promoters(downstream = 500, upstream = 1500) %>%
  sort()
```

```{r geneModels}
geneModels <- here::here("output/geneModels.rds") %>%
  read_rds()
geneRanges <- geneModels %>% 
  split(f = .$gene) %>% 
  range() %>% 
  unlist() %>%
  sort()
geneRanges$gene <- names(geneRanges)
geneRanges$symbol <- geneModels$symbol[match(geneRanges$gene, geneModels$gene)]
sq <- seqinfo(geneModels)
```

Gene and transcript models were loaded for plotting and data integration.
These were defined in the [Annotation Setup](annotation_setup.html) step of the workflow.
Gene models make for simpler plotting, whilst transcript models allow for more accurate identification of each TSS.

For this analysis, only the TSS of genes detected as expressed in the RNA-Seq dataset (Stripped Serum) were considered as viable TSS & promoters. 
Any peaks which overlapped undetectable gene promoters were considered more likely to be functioning as enhancers.

## Consensus Peaks

```{r chipGR}
chipGR <- here::here("data/external/BED") %>%
  list.files(pattern = "H3K27", full.names = TRUE) %>%
  sapply(import.bed, seqinfo = sq) %>%
  lapply(sort) %>%
  setNames(
    str_replace(names(.), ".+(E2.*)_peaks.bed", "\\1")
  ) %>%
  as("GRangesList") 
```

```{r consPeaks}
consPeaks <- chipGR %>%
  as("GRangesList") %>%
  unlist() %>%
  GenomicRanges::reduce() 
```

Consensus peaks were identified for each treatment group (E2 and E2+DHT), however for the purposes of super-enhancer detection, *these were merged to ensure the same candidate super-enhancer was being investigated in each cell type*.
Subtle shifts in ChIP peaks boundaries should remain relatively inconsequential for the relatively extreme criteria required for classification as a super-enhancer.

Whilst `r comma(length(chipGR$E2))` and `r comma(length(chipGR$E2_DHT))` consensus peaks were identified for E2 and E2+DHT respectively, when combining a total of `r comma(length(consPeaks))` regions were defined as the merged consensus peaks of the separate sets of consensus peaks.


## Promoters and Enhancers

```{r prom}
ol <- findOverlaps(tss, consPeaks, ignore.strand = TRUE)
promGR <- consPeaks[unique(subjectHits(ol))]
enhGR <- consPeaks[-unique(subjectHits(ol))]
stitchGR <- GenomicRanges::reduce(enhGR, min.gapwidth = 12500) %>%
  subset(width > 1e3)
```

After comparison with promoters (defined as TSS $\pm$ 2500bp), `r comma(length(promGR))` regions were classified as candidate promoters, whilst `r comma(length(enhGR))` were retained as candidate enhancers.
After stitching together peaks within 12.5kb of each other and removing peaks shorter than 1kb, the final set of `r comma(length(stitchGR))` candidate regions was formed.
Notably, these regions were independent of the initial treatment group, but were identification of super-enhancers will be performed separately in each treatment group.


```{r cutPromoters}
cutPromoters <- function(i, x = stitchGR, y = enhGR, p = promGR){
  
  ## To correct these ranges, we should first 'snip' the promoter peak from the 
  ## merged range, but just putting a hole in the range
  ## The first offender is stitchGR[12]
  x <- x[i]
  ## This merged 3 enhancers with the promoter being between 2 & 3
  y <- subsetByOverlaps(y, x)
  ## The promoter peak is
  p <- subsetByOverlaps(p, x) %>% range()
  ## Given we'll always have a range either side, we can just cut these
  xl <- range(subset(y, end < start(p)))
  xr <- range(subset(y, start > end(p)))
  ## Now we return the new ranges
  c(xl, xr)
}
```

```{r findStitchPromOverlap}
ol <- findOverlaps(stitchGR, promGR) %>%
  queryHits() %>%
  unique()
```

An issue produced by this method, is although peaks overlapping promoters were excluded, peaks straddling either side of the peaks directly overlapping a promoter may still be joined.
These were identified and any merged peaks with this characteristic were split either side of the overlapping peak.
A total of `r length(ol)` stitched regions were found to overlap a promoter and required 'unstitching' back into two separate regions either side of the promoter.

```{r unstitch}
nc <- detectCores() - 1
unstitched <- ol %>%
  mclapply(cutPromoters, mc.cores = nc) %>%
  as("GRangesList") %>%
  unlist()
stitchGR <- c(
  stitchGR[-ol],
  unstitched
) %>%
  sort() %>%
  subset(width > 1e3)
```


## Alignments

```{r bfl}
bfl <- here::here("data/external/H3K27AC/bam") %>%
  list.files(pattern= "bam$", recursive = TRUE, full.names = TRUE) %>%
  BamFileList()
```

```{r treat}
treat <- names(bfl) %>%
  str_replace_all(".+(E2.*|Pooled)_(input|merged).+", "\\1") %>%
  setNames(names(bfl))
```

```{r libSizes}
libSizes <- bfl %>%
  lapply(idxstatsBam) %>%
  lapply(pull, "mapped") %>%
  vapply(sum, numeric(1)) %>%
  divide_by(1e6)
```

The `.bam` files were assigned to a `BamFileList` object for simple parsing of each range.

```{r alnSummary}
pander(enframe(comma(1e6*libSizes), name = "BamFile", value = "Total Alignments"), caption = "Summary of alignments within each treatment group")
```

## Function Definitions

```{r calculate_cutoff}
calculate_cutoff <- function(inputVector, drawPlot=TRUE,...){
  inputVector <- sort(inputVector)
  inputVector[inputVector<0]<-0 #set those regions with more control than ranking equal to zero
  slope <- (max(inputVector)-min(inputVector))/length(inputVector) #This is the slope of the line we want to slide. This is the diagonal.
  xPt <- floor(optimize(numPts_below_line,lower=1,upper=length(inputVector),myVector= inputVector,slope=slope)$minimum) #Find the x-axis point where a line passing through that point has the minimum number of points below it. (ie. tangent)
  y_cutoff <- inputVector[xPt] #The y-value at this x point. This is our cutoff.
  
  if(drawPlot){  #if TRUE, draw the plot
    plot(1:length(inputVector), inputVector,type="l",...)
    b <- y_cutoff-(slope* xPt)
    abline(v= xPt,h= y_cutoff,lty=2,col=8)
    points(xPt,y_cutoff,pch=16,cex=0.9,col=2)
    abline(coef=c(b,slope),col=2)
    text(x = 0.25*length(inputVector), y = 0.9*max(inputVector), labels = paste("x=",xPt,"\ny=",signif(y_cutoff,3),"\nFold over Median=",signif(y_cutoff/median(inputVector),3),"x\nFold over Mean=",signif(y_cutoff/mean(inputVector),3),"x",sep=""))
    axis(1,sum(inputVector==0),sum(inputVector==0),col.axis="pink",col="pink") #Number of regions with zero signal
  }
  return(list(absolute=y_cutoff,overMedian=y_cutoff/median(inputVector),overMean=y_cutoff/mean(inputVector)))
}
```

```{r numPts_below_line}
numPts_below_line <- function(myVector,slope,x){
  yPt <- myVector[x]
  b <- yPt-(slope*x)
  xPts <- 1:length(myVector)
  return(sum(myVector<=(xPts*slope+b)))
}
```

As stated earlier, the two functions `calculate_cutoff()` and `numPts_below_line()` were copied directly from the [ROSE github software repository](https://github.com/rakarnik/ROSE/blob/master/ROSE_callSuper.R)

# Detection of Super-Enhancers

## Calculation of Enrichment Within Regions

```{r rpmpbp}
rpmpbp <- countBam(bfl, param = ScanBamParam(which = stitchGR)) %>%
  mutate(
    treat = treat[file],
    rpmpbp = (records / libSizes[file]) / width
  ) %>%
  pivot_wider(
    id_cols = c("space", "start", "end", "width"),
    names_from = treat,
    names_prefix = "rpmpbp_",
    values_from = rpmpbp
  ) %>%
  mutate(
    across(contains("rpm"), function(x){x - .$rpmpbp_Pooled})
  ) %>%
  dplyr::select(-contains("Pooled")) %>%
  dplyr::filter(
    rpmpbp_E2_DHT > 0,
    rpmpbp_E2 > 0
  )
```

```{r plotRpmpbp, fig.width=8, fig.cap = "Comparison of H3K27AC signal within each candidate region. The curve of best fit is shown in blue, with y = x shown as the dashed, grey line. Axes are both square-root transformed."}
rpmpbp %>%
  ggplot(aes(rpmpbp_E2_DHT, rpmpbp_E2)) + 
  geom_point() + 
  geom_smooth(se = FALSE) +
  geom_abline(slope = 1, linetype = 2, colour = "grey") +
  labs(
    x = "E2 + DHT (rpm/bp)",
    y = "E2 (rpm/bp)"
  ) +
  scale_x_sqrt() +
  scale_y_sqrt()
```

Reads per million / base pair (`rpm/bp`) were calculated as described above for each candidate region, with any receiving a background corrected value < 0 removed.
Values were then visually compared across treatments.
In the lower regions, signal strongly tracked the line `y = x`, whilst for the regions with the strongest signal, a trend of higher signal was observed in the merged E2 alignments.
This may represent bias in peak definitions (e.g. wider peaks predominately defined by one treatment group), the impact of the larger library size in the E2+DHT sample, or may even be genuine biology.

## Detection of Super-Enhancers

```{r plotRose, fig.height=6, fig.cap="Super-Enhancer Detection Using ROSE"}
par(mfrow = c(1, 2))
cuts <- c()
cuts$E2 <- calculate_cutoff(rpmpbp$rpmpbp_E2, main = "E2", ylab = "H3K27AC Signal (rpm/bp)", xlab = "Rank") %>% 
  as_tibble() %>% 
  mutate(treat = "E2")
cuts$E2_DHT <- calculate_cutoff(rpmpbp$rpmpbp_E2_DHT, main = "E2 + DHT", ylab = "H3K27AC Signal (rpm/bp)", xlab = "Rank") %>% 
  as_tibble() %>% 
  mutate(treat = "E2_DHT")
par(mfrow = c(1,1))
cuts %<>% bind_rows()
```

```{r assignSE}
rpmpbp %<>%
  mutate(
    class = case_when(
      rpmpbp_E2_DHT > dplyr::filter(cuts, treat == "E2_DHT")$absolute & 
        rpmpbp_E2 > dplyr::filter(cuts, treat == "E2")$absolute ~ "Both",
      rpmpbp_E2_DHT > dplyr::filter(cuts, treat == "E2_DHT")$absolute ~ "E2 + DHT Only",
      rpmpbp_E2 > dplyr::filter(cuts, treat == "E2")$absolute ~ "E2 Only",
      TRUE ~ "Not SE"
    )
  ) 
```



```{r tabSE}
rpmpbp %>%
  group_by(class) %>%
  summarise(
    n = n(),
    Smallest = min(width),
    `median width` = median(width),
    Largest = max(width)
  ) %>%
  rename_all(str_to_title) %>%
  pander(
    caption = "Summary of Super-Enhancers detected by treatment. The median width for each class is also given"
  )
```

Initial analysis revealed that many more super-enhancers were identified in the DHT treated samples, which is counter-intuitive to the observations made with regard to raw signal.
It was also noted that the median length of the super enhancers identified in both treatment groups was much longer than the tissue-specific SEs.
A comparison of H3K27Ac signal for each region was then performed.

```{r compareSE, fig.width=8, fig.cap = "Comparison of H3K27AC signal in the two treatment groups for each type of super-enhancer. ROSE thresholds for inclusion as a super enhancers are shown as grey dashed lines."}
rpmpbp %>%
  ggplot(aes(rpmpbp_E2_DHT, rpmpbp_E2)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  geom_abline(slope = 1, linetype = 2) +
  geom_vline(xintercept = dplyr::filter(cuts, treat == "E2_DHT")$absolute, colour = "grey", linetype = 2) +
  geom_hline(yintercept = dplyr::filter(cuts, treat == "E2")$absolute, colour = "grey", linetype = 2) +
  scale_y_sqrt() +
  scale_x_sqrt() +
  scale_colour_manual(
    values = c(rgb(0.1, 0.8, 0.1), rgb(0.8, 0.2,0.2), rgb(0.2, 0.2, 0.8), rgb(0.7, 0.7,0.7,0.5))
  ) +
  coord_cartesian(
    xlim = c(0.001, 0.03),
    ylim = c(0.001, 0.03)
  ) +
  labs(
    x = "E2 + DHT (rpm/bp)",
    y = "E2 (rpm/bp)",
    colour = "SE Detection"
  )
```

After checking the plot above, it appears that an increase in SE activity can be partially attributed to DHT treatment.
A series of putative super enhancers detected in the E2 + DHT treatment group fall non-trivially below the cutoff value for the E2 only treatment group, whilst the converse is not observed.
Those classified as E2 only clearly appear artefactual, and whilst many specific to the E2 + DHT group also appear so, a select group of super enhancers do not.

The detected set of super-enhancers were exported, along with the original set of peaks which do not overlap a detected super enhancer.
These peaks were additionally divided into promoters and enhancers.

```{r export}
seGR <- rpmpbp %>%
  dplyr::filter(class != "Not SE") %>%
  makeGRangesFromDataFrame(
    seqnames.field = "space",
    keep.extra.columns = TRUE,
    seqinfo = sq
  )
export.gff(seGR, "output/SE.gtf")
ol <- findOverlaps(enhGR, seGR)
enhGR <- enhGR[-unique(queryHits(ol))]
export.bed(enhGR, "output/enhancers.bed")
export.bed(promGR, "output/promoters.bed")
```

A comparison of region widths was then performed and it was noted that some regions annotated as promoters were extremely long.
This may be the result of some genes containing multiple TSS, but also the original peak calling may have merged multiple peaks into a larger peak.

```{r compareWidths, fig.width=8, fig.height=6, fig.cap="*Comparison of region widths for promoters, enhancers and super-enhancers after running the above processes.*"}
list(
  tibble(width = width(promGR), region = "Promoter"),
   tibble(width = width(enhGR), region = "Enhancer"),
   tibble(width = width(seGR), region = "Super Enhancer")
) %>%
  bind_rows() %>%
  mutate(region = fct_inorder(region)) %>%
  ggplot(aes(region, width)) +
  geom_boxplot() +
  labs(x = "Region", y = "Region Width (bp)") +
  scale_y_log10(labels = scales::comma)
```


# Inspection of Results {.tabset}

After identification of SEs, regions considered as SE in any condition were exported as a distinct set of regions, whilst enhancers not considered as an SE were exported as a distinct set of enhancers.
This gave three distinct types of binding regions: 1) Promoters, 2) Enhancers and 3) Super Enhancers.
Individual ChIP Peaks and BigWig files (i.e. scaled coverage) were inspected at key sites, incorporating HiC information and manually checking RNA-Seq expression.

- Significant interactions detected in the HiC data using bins of 20kb, 40kb and 100kb were combined into a single set of interactions
- The ChromHMM model for HMEC cells was also prepared as a track for plotting
- In all plots below, the RNA-Seq data was combined with the H3K27AC data to give four basic classifications for peaks and known exons.
    1. Active Promoter
    2. Transcription
    3. Enhancer
    3. Super Enhancer
- Colours for the above were identical to the ChromHMM model, with the exception of *colouring super-enhancers blue.*

```{r bw}
bw <- here::here("data/external/H3K27AC/bigwig") %>%
  list.files(pattern = "_[1-3].bigwig", full.names = TRUE) %>%
  BigWigFileList() %>%
  setNames(
    str_replace_all(path(.), ".+T47D_(.+).bigwig", "\\1")
  )
bwCols <- case_when(
  grepl("DHT", names(bw)) ~"red", 
  grepl("Pooled", names(bw)) ~ "grey",
  grepl("E2_[1-3]", names(bw)) ~ "blue"
) %>%
  setNames(names(bw))
```


```{r chromHmm}
stateMap <- read_rds(here::here("output/stateMap.rds"))
chromCols <- setNames(stateMap$itemRgb, stateMap$name)
hmecHMM <- import.bed("data/external/ChromHMM/E119_25_imputed12marks_dense.bed.gz", seqinfo = sq) %>%
  sort()
```

```{r gi}
gi100 <- here::here("output/gi_100000.rds") %>% read_rds()
gi40 <- here::here("output/gi_40000.rds") %>% read_rds()
gi20 <- here::here("output/gi_20000.rds") %>% read_rds()
gi10 <- here::here("output/gi_10000.rds") %>% read_rds()
gi <- c(gi10, gi20, gi40, gi100)
gi$distance <- pairdist(gi)
gi$logObsExp <- log2(gi$counts / gi$exp_interactions)
```


```{r ax}
gen <- "hg19"
ax <- GenomeAxisTrack()
```


```{r plotRegion}
plotRegion <- function(gr, zoom = 1, hic = gi, hmm = hmecHMM, prom = promGR, enh = enhGR, se = seGR, gm = geneModels, .bw = bw, .bwCols = bwCols, .ax = ax, rna = rnaseq, maxIntDist = 1e6){
  
  stopifnot(is(gr, "GRanges") | length(gr) > 0)
  
  ## Form the Ideogram track
  chr <- unique(as.character(seqnames(gr)))
  ideo <- IdeogramTrack(genome = gen, chromosome = chr)
  
  ## The HiC Track
  goiInteractions <- hic %>%
    subsetByOverlaps(gr, ignore.strand = TRUE) %>%
    # subset(distance < width(gr)*zoom) %>%
    subset(distance < maxIntDist) %>%
    as("GenomicInteractions")
  hicTR <- goiInteractions %>%
    InteractionTrack(
      chromosome = chr,
      name = "HiC"
    )
  
  ## Expand the range  
  gr <- resize(gr, width = zoom*width(gr), fix = "center")
  
  ## The ChromHMM track
  hmmTR <- hmm %>%
    subsetByOverlaps(gr, ignore.strand = TRUE) %>%
    AnnotationTrack(
      name = "HMEC",
      id = .$name,
      stacking = "dense",
      feature = .$name,
      group = .$name,
      col = "transparent",
      `1_TssA` = "#FF0000", `10_TxEnh5'` = "#C2E105", `11_TxEnh3'` = "#C2E105",
      `12_TxEnhW` = "#C2E105", `13_EnhA1` = "#FFC34D", `14_EnhA2` = "#FFC34D",
      `15_EnhAF` = "#FFC34D", `16_EnhW1` = "#FFFF00", `17_EnhW2` = "#FFFF00",
      `18_EnhAc` = "#FFFF00", `19_DNase` = "#FFFF66", `2_PromU` = "#FF4500",
      `20_ZNF/Rpts` = "#66CDAA", `21_Het` = "#8A91D0", `22_PromP` = "#E6B8B7",
      `23_PromBiv` = "#7030A0", `24_ReprPC` = "#808080", `25_Quies` = "#FFFFFF",
      `3_PromD1` = "#FF4500", `4_PromD2` = "#FF4500", `5_Tx5'` = "#008000",
      `6_Tx` = "#008000", `7_Tx3'` = "#008000", `8_TxWk` = "#009600",
      `9_TxReg` = "#C2E105"
    )
  
  # Setup the promoters, enhancers and super-enhancers like a 3-state ChromHMM track.
  # Maybe include the detected genes as 'Transcription'
  prom <- granges(prom)
  prom$name <- "Promoter"
  enh <- granges(enh)
  enh$name <- "Enhancer"
  se <- granges(se)
  se$name <- "Super-Enhancer"
  exons <- subset(gm, gene %in% rna$gene_id)
  exons <- granges(exons)
  exons$name <- "Transcription"
  h3K27ac <- GRangesList(prom, enh, se, exons) %>%
    unlist() %>%
    sort()
  strand(h3K27ac) <- "*"
  noFeature <- gaps(h3K27ac)
  noFeature <- subset(noFeature, strand == "*")
  noFeature$name <- "None"
  h3K27ac <- GRangesList(
    h3K27ac,
    noFeature
  ) %>%
    unlist() %>%
    sort()
  h3K27acTR <- h3K27ac %>%
    subsetByOverlaps(gr, ignore.strand = TRUE) %>%
    AnnotationTrack(
      name = "H3K27+RNA",
      stacking = "dense",
      id = .$name,
      feature = .$name,
      group = .$name,
      col = "transparent",
      fontsize = 12,
      size = 1.5,
      `Promoter` = "#FF4500",
      `Enhancer` = "#FFC34D",
      `None` = "#FFFFFF",
      `Transcription` = "#008000",
      `Super-Enhancer` = "#0000FF" # This is blue, not used by ChromHMM!
    )
  
  # The bigwig tracks
  dtl <- names(.bw) %>%
    lapply(function(x){
      import(.bw[[x]], which = gr) %>%
        DataTrack(
          name = x, type = "l", 
          col = .bwCols[[x]],
          size = 1
        )
    })
  # Now form the plot
  list(
    ideo, .ax, hicTR, hmmTR
  ) %>%
    c(h3K27acTR) %>%
    c(
      subsetByOverlaps(gm, gr, ignore.strand = TRUE) %>%
        GeneRegionTrack(
          name = "Genes",
          transcriptAnnotation = "symbol"
          )
    ) %>%
    c(dtl) %>%
    plotTracks(
      from = start(gr),
      to = end(gr)
    )
}
```


## The most highly ranked SE

```{r gr_highest}
gr <- subset(seGR, rpmpbp_E2 == max(rpmpbp_E2))
gn <- subsetByOverlaps(geneRanges, gr)
```

Of all the putative super-enhancers, the most highly ranked in both conditions was the same.
This was located on `r as.character(seqnames(gr))` and had a width of `r width(gr)`bp, being located within the overall range of `r pander(as.character(gn$symbol))`.
In addition, it appears this SE was only generated from one initial ChIP peak.

Whilst no differential expression was found for `r pander(as.character(gn$symbol))`, it was expressed at low levels in T47D despite no discernible H3K27AC signal in it's promoter region.
The mid-gene super enhancer also appeared to connect with the genes own promoter.


```{r pltHighest, fig.cap = "*The most highly ranked super-enhancer in both treatments. HiC Interactions with the SE are shown using 10, 20, 40 & 100kb bins combined, and are restricted to those within 1Mb. The ChromHMM model was generated using HMEC cells*"}
plotRegion(gr, zoom = 130)
```

## The next most highly ranked SE

```{r gr_next}
gr <- seGR %>% 
  subset(rpmpbp_E2_DHT < max(rpmpbp_E2_DHT)) %>% 
  subset(rpmpbp_E2_DHT == max(rpmpbp_E2_DHT))
gn <- subsetByOverlaps(geneRanges, gr)
```

The next most highly ranked super-enhancer was located in an intergenic region. 
A HiC Interaction was detected between this SE and *DDX6*, although this was unlikely to be to the promoter of this gene.
As this was a conserved super-enhancer, no logFC was observed at *DDX6* although the gene itself was highly expressed.

Despite the SE being located proximal to *CXCR5*, this gene was not detected as expressed in the RNA-Seq data.

```{r plotNext, fig.cap = "*The second most highly ranked super-enhancer. Connections were noted between this SE and DDX6.*"}
plotRegion(gr, zoom = 70, hic = gi)
```

## A Super Enhancer Detected in E2 + DHT Only

```{r grDHT}
gr <- seGR %>% 
  subset(class == "E2 + DHT Only") %>%
  subset(rpmpbp_E2 == min(rpmpbp_E2))
zm <- 1e3
gn <- geneRanges %>%
  subsetByOverlaps(
    resize(gr, width = zm*width(gr), fix = "center"), ignore.strand = TRUE
  ) %>%
  subset(gene %in% rnaseq$gene_id)
```


The most divergently ranked super enhancer was explored next, with a width of `r width(gr)`bp.
This was again located in an intergenic region, and was clearly lost in E2 samples, as expected.
Whilst the signal in E2 + DHT was detectable, it is worth noting that this enhancer was still a relatively low-ranked SE in this treatment group.

No HiC connections were detected.

```{r plotDHT, fig.cap = "*Close view of the central super enhancer gained in E2 + DHT*"}
plotRegion(gr, zoom = 100, hic = gi)
```


## The largest SE

```{r largestSE}
gr <- seGR %>% subset(width == max(width))
zm <- 8
gn <- geneRanges %>%
  subsetByOverlaps(resize(gr, width = zm*width(gr), fix = "center"), ignore.strand = TRUE) %>%
  subset(gene %in% rnaseq$gene_id)
```

The largest SE by size was found to be `r width(gr)/1e3`kb wide.
Several long-range interactions were observed.

```{r plotLargest, fig.cap = "*View of the longest super enhancer detected in this dataset*"}
plotRegion(
  gr, zoom = zm, 
  hic = gi, 
  # gm = subset(geneModels, gene %in% names(gn)), 
  maxIntDist = 1e7
)
```

## The longest SE in the top 5 ranked SEs

```{r largest_high}
gr <- subset(seGR, width == 19912)
gn <- geneRanges %>%
  subsetByOverlaps(resize(gr, width = zm*width(gr), fix = "center"), ignore.strand = TRUE) %>%
  subset(gene %in% rnaseq$gene_id)
```

This specific SE was `r round(width(gr)/1e3, 1)`kb long.

```{r plotLargestHigh, fig.cap = "*The longest SE in the top 5 ranked across both conditions*"}
plotRegion(gr, zoom = 100, hic = gi)
```


# Conclusion

Whilst adhering to the ROSE approach, some of the identified super-enhancers appear to be somewhat less than compelling.
Integration with other ChIP Seq data, or other data types may be prudent to confirm the status.
